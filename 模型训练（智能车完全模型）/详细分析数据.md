

本届比赛共有2069张可直接用于训练的数据，其图像与标注文件命名一致，组织结构如下：

```
Car2024
├── annotations
│   └── block1.xml
│   └── block2.xml
│   └── ... ...
└── images
│   └── block1.jpg
│   └── block2.jpg
│   └── ... ...
└── label_list.txt
```


## analyze.py：

```
import argparse
from DataAnalyze import DataAnalyze

def parse_args():
    parser = argparse.ArgumentParser(description='dataset analyze')
    parser.add_argument('type', type=str, help="Dataset format, optional 'voc' and 'coco'")
    parser.add_argument('path', type=str, help='Dataset path, if it is a voc dataset, it corresponds '
                                               'to the xml directory, if it is a coco dataset, it is the json file '
                                               'path')
    parser.add_argument('--out', type=str, default='out', help='Result output directory')
    return parser.parse_args()


def main():
    args = parse_args()
    DataAnalyze(args.type, args.path, args.out)


if __name__ == '__main__':
    main()

```


### 代码解释：

1. **导入模块和包**：    
    - `argparse`：用于解析命令行参数和选项的标准库模块。它使程序能够从命令行接受参数，从而提供灵活的用户接口。
    - `DataAnalyze`：从`DataAnalyze.py`文件中导入。

1. **定义`parse_args`函数**：
    - 函数创建了一个`ArgumentParser`对象，用于指定程序能够接受哪些命令行参数。
    - `add_argument`方法用来指定接受的参数。这里定义了三个参数：
        - `type`：一个位置参数，表示数据集的格式，它是必须的。接受的值为字符串，用于指定数据集的格式（例如，'voc'或'coco'）。
        - `path`：另一个位置参数，表示数据集的路径。对于VOC格式，这应该是XML文件的目录；对于COCO格式，这应该是JSON文件的路径。
        - `--out`：一个可选参数，用于指定结果输出的目录，默认值为'out'。这个参数是用两个破折号前缀定义的，表明它是一个可选参数。
    - `parse_args()`方法用来解析命令行中提供的参数，并返回一个包含参数值的命名空间对象。
2. **定义`main`函数**：
    - 首先，它调用`parse_args`函数获取命令行参数。
    - 然后，使用这些参数（数据集类型、路径和输出目录）创建了一个`DataAnalyze`实例。这一步实际上启动了数据集的分析过程，尽管具体的分析逻辑没有在这段代码中给出，它应该是`DataAnalyze`类中定义的。


### 运行代码：

```
%cd /home/aistudio/work/DataAnalyze

!python analyze.py voc /home/aistudio/Car2024/annotations/ --out ./out/
```

`voc`是`analyze.py`脚本的第一个位置参数，指定了数据集的格式为"voc"。
`/home/aistudio/Car2024/annotations/`脚本的位置参数，指定了数据集文件的路径。根据脚本中的参数描述，因为数据集格式被指定为`voc`，路径指向存放XML描述文件的目录。
`--out ./out/`可选参数，用于指定分析结果输出的目录。这里的路径是`./out/`，意味着输出目录位于当前工作目录下的`out`文件夹中。


## DataAnalyze.py：

```
import os
from utils.read import *
from utils.data import *
from utils.draw import *
from utils.excel import *

class DataAnalyze:
    """
    voc or coco dataset analyze
    """
    def __init__(self, type, path, outPath):
        """
        :param type: dataset format, optional: 'coco', 'voc'
        :param path: dataset path
        :param outPath: result path
        """
        self.outPath = outPath

        if not os.path.exists(self.outPath):
            os.makedirs(self.outPath)

        print('Processing, please wait...')

        if type == 'coco':
            self.analyzeInfo(readCoco(path))
            self.output()
        elif type == 'voc':
            self.analyzeInfo(readVoc(path))
            self.output()
        else:
            print('Currently only voc and coco formats are supported, please check if the first parameter is correct.')
        
        print(f'Processing completed. The result is saved in {self.outPath}.')

    def calEachCategorieNum(self, categorie):
        if categorie not in self.eachCategoriesNum.keys():
            self.eachCategoriesNum.update({categorie: 1})
        else:
            self.eachCategoriesNum[categorie] += 1


    def calEachCategorieBbox(self, categorie, bboxWH):
        if categorie not in self.eachCategoriesBbox.keys():
            self.eachCategoriesBbox.update({categorie: [[bboxWH[0]], [bboxWH[1]]]})
        else:
            self.eachCategoriesBbox[categorie][0].append(bboxWH[0])
            self.eachCategoriesBbox[categorie][1].append(bboxWH[1])


    def analyzeInfo(self, info_data):
        self.imagesWH = [[], []]
        self.bboxsWH = [[], []]
        self.anchorRatios = []
        self.eachCategoriesNum = {}
        self.eachCategoriesBbox = {}
        self.eachCategoryImageNum = {}
        self.eachImageCategoryNum = {}
        self.eachImageBboxNum_list = []
        self.sizeBboxNum = dict.fromkeys(['small', 'medium', 'large'], 0)
        self.imagesNum = len(info_data)
        for info in info_data:
            w, h = getImageWH(info)
            self.imagesWH[0].append(w)
            self.imagesWH[1].append(h)
            calculatedCategory = []
            for obj in info['bndbox']:
                [bboxW, bboxH], anchorRatio, categorie, sizeType = getBboxInfo(info['file'], obj)

                self.calEachCategorieNum(categorie)
                self.bboxsWH[0].append(bboxW)
                self.bboxsWH[1].append(bboxH)
                self.calEachCategorieBbox(categorie, [bboxW, bboxH])
                if anchorRatio != -1:
                    self.anchorRatios.append(anchorRatio)
                if obj['objName'] not in self.eachCategoryImageNum.keys():
                    self.eachCategoryImageNum[obj['objName']] = 1
                    calculatedCategory.append(obj['objName'])
                elif obj['objName'] not in calculatedCategory:
                    self.eachCategoryImageNum[obj['objName']] += 1
                    calculatedCategory.append(obj['objName'])
                if sizeType == 1:
                    self.sizeBboxNum['small'] += 1
                elif sizeType == 2:
                    self.sizeBboxNum['medium'] += 1
                elif sizeType == 3:
                    self.sizeBboxNum['large'] += 1
            if len(calculatedCategory) in self.eachImageCategoryNum:
                self.eachImageCategoryNum[len(calculatedCategory)] += 1
            else:
                self.eachImageCategoryNum[len(calculatedCategory)] = 1
            self.eachImageBboxNum_list.append(len(info['bndbox']))
        self.bboxNum = len(self.anchorRatios)

    def output(self):
        print('\n***************** Info *****************\n')
        print('number of images: %d' % self.imagesNum)
        print('number of boxes: %d' % len(self.anchorRatios))
        className_list = set(self.eachCategoriesNum.keys())
        print('classes = ', list(className_list))
        print('\n***************** Info *****************\n')

        print('Exporting images, please wait...')
        draw = Draw(self.outPath)
        draw.drawEachCategoryBboxWH(self.eachCategoriesBbox)
        draw.drawImageWHScatter(self.imagesWH)
        draw.drawBboxWHScatter(self.bboxsWH)
        draw.drawSizeBboxNum(self.sizeBboxNum)
        draw.drawAnchorRatioBar(self.anchorRatios)
        draw.drawEachCategoryImagesNum(self.eachCategoryImageNum)
        draw.drawEachCategoryNum(self.eachCategoriesNum)
        draw.drawEachImageBboxNum(self.eachImageBboxNum_list)
        print('Export images completed.')

        # print('Exporting Excel table, please wait...')
        # excel = Excel(self.outPath)
        # excel.imageWH(self.imagesWH)
        # excel.bboxWH(self.bboxsWH)
        # excel.anchorRatio(self.anchorRatios)
        # excel.eachCategory(self.eachCategoriesNum)
        # excel.eachCategoryImagesNum(self.eachCategoryImageNum)
        # excel.eachImageBboxNum(self.eachImageBboxNum_list)
        # excel.sizeBboxNum(self.sizeBboxNum)
        # excel.eachCategoryBboxWH(self.eachCategoriesBbox)
        # print('Export Excel table completed.')



```

### 代码解释：


**初始化方法 `__init__(self, type, path, outPath)`**

- 参数`type`指定了数据集的格式（`coco`或`voc`）。
- 参数`path`是数据集文件的路径。
- 参数`outPath`是结果输出的目录。
- 初始化方法首先检查结果输出目录是否存在，如果不存在，则创建它。
- 根据数据集的格式（`coco`或`voc`），读取数据集并分析信息。这通过调用`readCoco`或`readVoc`函数来完成，这些函数很可能返回数据集的详细信息，例如图像尺寸、边界框信息等。
- 然后调用`output`方法来输出分析结果。

**方法 `calEachCategorieNum(self, categorie)` 和 `calEachCategorieBbox(self, categorie, bboxWH)`**

- 这些方法用于计算每个类别的数量以及每个类别边界框的尺寸（宽度和高度）。
- 如果类别首次出现，则初始化计数或尺寸列表；如果已存在，则更新这些信息。

**方法 `analyzeInfo(self, info_data)`**

- 这个方法接收数据集的信息并进行分析。
- 它初始化或更新各种统计信息，包括图像尺寸、边界框尺寸、锚框比例、每个类别的数量和尺寸、每个图像中的类别数量和边界框数量等。
- 方法使用了一系列的辅助函数（如`getImageWH`和`getBboxInfo`），这些函数从数据集信息中提取特定的细节。

**方法 `output(self)`**

- 此方法打印基本的数据集信息，例如图像数量、边界框数量、类别等。
- 使用`Draw`类（在`utils.draw`模块中定义的）来绘制和导出不同的图表和可视化，例如每个类别边界框的宽度和高度、图像尺寸分布、边界框尺寸分布、锚框比例、各类别的图像数量等。
- 这个方法表明分析的结果会以图像的形式输出。



`analyze.py`脚本通过调用`DataAnalyze`类来进行数据集的分析，而不是直接进行模型训练。这个分析主要关注数据集本身的特性，比如：

- 图像的宽度和高度分布
- 各个类别的数量
- 每个类别中边界框（bounding box）的尺寸分布
- 边界框的尺寸类型（小、中、大）
- 锚框（anchor box）的比例



## 只是分析标签

```

import os

from unicodedata import name

import xml.etree.ElementTree as ET

import glob

  

def count_num(indir):

    os.chdir(indir)

    annotations = os.listdir('.')

    annotations = glob.glob(f'{str(annotations)}*.xml')

  

    dict = {}

    for file in annotations:

        in_file = open(file, encoding = 'utf-8')

        tree = ET.parse(in_file)

        root = tree.getroot()

  

        for obj in root.iter('object'):

            name = obj.find('name').text

            if name in dict: dict[name] += 1

            else: dict[name] = 1

  

    print("各类标签的数量分别为：")

    for key in dict:

        print(f'{key}: {str(dict[key])}')            

  

indir='/home/aistudio/Car2024/annotations'   # xml文件所在的目录

count_num(indir) # 调用函数统计各类标签数目
```