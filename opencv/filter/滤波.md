# 图像处理

## 什么是形态学？

形态学（Morphology）在图像处理领域是一种以形状为基础的技术集合，主要用于分析和处理图像中的几何结构。它起源于数学的一部分，特别是集合论和拓扑学，后来在图像处理领域被广泛应用。以下是形态学处理的应用：

1.	噪声去除：通过腐蚀和膨胀组合使用，可以有效去除图像中的小噪声点。
2.	形状分析：形态学处理可以帮助识别图像中的形状，如计数对象、测量大小和形态学特征。
3.	图像分割：在处理复杂图像时，形态学操作有助于分割和突出显示不同的结构或区域。
4.	边缘检测：形态学梯度，即膨胀和腐蚀的差异，可用于突出显示图像的边缘。
5.	填充孔洞：膨胀操作可用于填充图像中的小孔洞。
6.	连通性分析：形态学操作有助于分析图像中对象的连通性，例如连接断开的组件。

### 形态学操作主要有哪些？

形态学操作是图像处理中用于分析和处理图像几何结构的一系列方法。主要的形态学操作包括：

1. **腐蚀（Erosion）**：此操作通过结构元素“侵蚀”图像的边缘，减小亮区域。腐蚀可以去除小的噪声点，分离相邻对象，使对象的边缘变得更加清晰。

2. **膨胀（Dilation）**：与腐蚀相反，膨胀通过结构元素增加图像中的亮区域。膨胀通常用于填充图像中的小孔，连接接近的对象，增加对象区域。

3. **开运算（Opening）**：首先进行腐蚀，然后进行膨胀。开运算用于去除小对象或细节（如噪声），同时保持较大对象的大小基本不变。

4. **闭运算（Closing）**：首先进行膨胀，然后进行腐蚀。闭运算用于填充小孔和小裂缝，同时保持较大对象的形状。

5. **形态学梯度（Morphological Gradient）**：是图像膨胀和腐蚀之间的差异。它突出显示了图像中对象的轮廓。

6. **顶帽运算（Top Hat）**：原始图像与开运算结果的差。顶帽运算用于突出比邻近区域亮的小对象。

7. **底帽运算（Black Hat）**：闭运算结果与原始图像的差。底帽运算用于突出比邻近区域暗的小对象。

8. **击中击不中（Hit-or-Miss）**：这是一种更复杂的形态学操作，用于寻找特定形状和大小的对象。



### 腐蚀操作

![](/images/9.png)
怎么理解这个过程呢？

二值图像的处理过程：

在你设计出来的一个核中（在滤波那里有介绍，可以移到那里观看），腐蚀的作用就是把它所覆盖的地方有0的地方变成0,非0的地方不用处理即可。

比如说左侧是你需要处理的图像，右侧是你所设计的核，将核覆盖在你的图像之上之后看是遍历，作“滑”的动作，在覆盖的位置，如果数值没有0的存在，完全不用去理会；

![](/images/10.png)

如果存在0,即如图，在核放在图像正中间的地方变成了数字0

![](/images/13.png)

如果是灰度图形

在这种情况下，像素值通常在0到255之间。此时，腐蚀操作的“求最小值”意味着在核覆盖的区域内选择最小的像素值，并将这个最小值**赋给核中心的像素**。这种情况下，最小值不一定是0，它可以是任何介于0到255之间的值。



### 膨胀操作

![](/images/8.png)

理解了腐蚀，膨胀是不是简单多了？

在二值化中，腐蚀赋予给核中心的值是存在 核覆盖图像中出现0的区域。而在灰度图像之中，就将核中心替换成了核覆盖在图像之中最小的数字。

膨胀相反就好了，在二值化中，对应的便是找到核覆盖为1的值将核中心给替换；在灰度图像之中，就是核覆盖后最大的数字替换了核中心的数。





### 开运算Opening 闭运算closing

闭运算Closing：腐蚀，然后进行膨胀

![](/images/16.png)

![](/images/15.png) 

开运算opening：膨胀，然后进行腐蚀

![](/images/14.png)





## 什么是滤波？



图片需要滤波，那什么是滤波？

- 消除图像在数字化过程中产生或者混入的噪声。
- 提取图片对象的特征作为图像识别的特征模式

滤波器该如何去理解?

- 滤波器可以想象成一个包含加权系数的窗口或者说一个镜片，当使用滤波器去平滑处理图像的时候，就是把通过这个窗口或者镜片去看这个图像。

在知乎看见一张这样的图片

![img](https://pic4.zhimg.com/v2-c4934e0d781650ed7b5f3b05f5f0a3c3_r.jpg)

滤波的种类有很多种，一般用来平滑图像或者增强图像。大致分为：

线性图像滤波：

- 高斯滤波
- 均值滤波

非线性图像滤波

- 中值滤波
- 双边滤波
- 引导滤波



### 滤波核

滤波核，也称为卷积核或滤波器，是在图像处理和信号处理中广泛使用的一个概念。它是一个通常较小的矩阵，用于修改、改进或分析图像和其他信号。

1. **定义**：滤波核是一个通常是二维的矩阵，它通过与图像中的像素及其邻近像素的组合应用，用于实现某种特定的图像处理操作。

2. **应用方式**：滤波核通过一种称为卷积的操作应用于图像。在卷积过程中，滤波核会在图像上滑动，每次都覆盖图像的一个小区域，并计算该区域与滤波核元素的加权和，生成新图像的对应像素。

3. **用途**：滤波核可以用于多种图像处理任务，如模糊、锐化、边缘检测、降噪等。不同的滤波核设计用于完成不同的任务。

4. **常见类型**：
   - **平滑滤波核**：用于模糊和降噪，如均值滤波器和高斯滤波器。
   - **锐化滤波核**：增强图像的边缘和细节。
   - **边缘检测滤波核**：用于提取图像的边缘，如Sobel或Canny边缘检测器。

5. **大小和形状**：滤波核的大小和形状可以根据需要选择。常见的尺寸有 3x3, 5x5, 7x7 等。滤波核的大小会影响其对图像的影响程度。

6. **自定义滤波核**：除了标准的滤波核之外，用户也可以创建自定义滤波核来实现特定的图像处理效果或解决特定问题。

滤波核是图像处理和计算机视觉领域的基本工具之一，几乎所有的图像处理库和软件都提供了各种内置的滤波核以及应用它们的方法。

核说白了就是一个代表的数字总和加起来为1的矩形，这里的数字会有不同的算法来确定，一旦确定了这里对应的数，放在图像处理中会有不同的效果。

**所谓不同的滤波，其实也就是改变了核的值，在乘出来会有不同的数，得到了不同的图像罢了。**

建议观看`3b1b`的卷积～

### 均值滤波

均值滤波是一种在图像处理中常用的简单滤波技术，用于平滑图像和减少噪声。它的基本原理和操作步骤如下：

#### 基本原理

1. **定义滤波核**：均值滤波使用一个定义好的“窗口”（通常是一个正方形区域，如3x3, 5x5等大小），这个窗口称为滤波核。

2. **滑动窗口**：这个滤波核在整个图像上滑动，每次覆盖图像的一个小区域。

3. **计算平均值**：在每个窗口位置，计算覆盖区域内所有像素的平均值。

4. **替换中心像素**：将这个平均值赋给窗口中心的像素。这样，每个像素的新值是其邻域像素值的平均值。

#### 应用和效果

- **平滑处理**：均值滤波可以平滑图像，减少像素间的强烈变化，这在降低图像噪声时特别有效。

- **模糊效果**：由于它取邻域内像素的平均值，均值滤波也会产生一定的模糊效果，这可能会使图像失去一些细节和边缘信息。

这里介绍下均值滤波较为简单，假设一个$3*3$的矩阵，矩阵对应的每一个数字就是核内像素的数量分之一。

![](/images/5.png)

### 高斯滤波

**高斯滤波是一种线性平滑滤波，适用于消除高斯噪声。**所以在讲高斯滤波之前，先解释一下什么是高斯噪声？

#### 高斯噪声

**噪声**在图像当中常表现为一引起较强视觉效果的孤立像素点或像素块。

简单来说，噪声的出现会给图像带来干扰，让图像变得不清楚。 

高斯噪声就是它的概率密度函数服从高斯分布（即正态分布）的一类噪声。

如果一个噪声，它的幅度分布服从高斯分布，而它的功率谱密度又是均匀分布的，则称它为**高斯白噪声**。

高斯白噪声的二阶矩不相关，一阶矩为常数，是指先后信号在时间上的相关。

**正态分布**：高斯噪声遵循正态分布（或高斯分布），这意味着噪声的值围绕某个平均值（通常是0）对称分布，并且大多数噪声值接近平均值。

1. **参数**：高斯噪声通常由两个参数描述：均值（mean）和标准差（standard deviation）。均值描述了噪声值的平均水平，而标准差描述了噪声值围绕均值的分散程度。

2. **随机性**：高斯噪声是随机的，每个点的噪声值是独立且随机生成的，遵循同一分布。

3. **应用**：在图像处理中，高斯噪声可以模拟由于光照变化、传感器不完善或传输错误等因素引入的噪声。它也被用于信号处理、通信系统、医学成像和机器学习等领域。

4. **滤波处理**：高斯噪声可以通过各种滤波技术进行减少或去除，例如使用高斯滤波器或其他低通滤波器。

5. **与其他类型噪声的比较**：与其他类型的噪声（如盐和胡椒噪声、泊松噪声等）相比，高斯噪声的特点是其连续性和广泛性，即噪声值连续分布且可能影响图像的每个像素。

**高斯滤波器是根据高斯函数的形状来选择权值的线性平滑滤波器** 所以接下来再讲解一下高斯函数和高斯核。

#### 高斯函数

 **高斯滤波的重要两步就是先找到高斯模板然后再进行卷积**

一维高斯分布：
$$
G(x) = \frac{1}{\sigma\sqrt{2\pi}} e^{-\frac{x^2}{2\sigma^2}}
$$
二维高斯分布：
$$
G(x,y) = \frac{1}{\sigma^2{2\pi}} e^{-\frac{x^2+y^2}{2\sigma^2}}
$$
高斯分布在所有定义域上都有非负值，这就需要一个无限大的卷积核。实际上，仅需要取均值周围3倍标准差内的值，以外部份直接去掉即可。 

**高斯滤波的重要两步就是先找到高斯模板然后再进行卷积**，模板（mask在查阅中有的地方也称作掩膜或者是高斯核）。

所以这个时候需要知道它怎么来？又怎么用？ 举个栗子： 假定中心点的坐标是（0,0），那么取距离它最近的8个点坐标，为了计算，需要设定σ的值。假定σ=1.5，则模糊半径为1的高斯模板就算如下

![](/images/4.png)

这个时候我们就需要确保这九个点加起来为1（这个是高斯模板的特性)，这9个点的权重总和等于0.4787147，因此上面9个值还要分别除以0.4787147，得到最终的高斯模板。

怎么计算高斯滤波呢？

就是用生成的核，在图片上‘过一遍’，我们把中间给的权重加大，在外边的权重法缩小，总和相加为1。

移动相关核的中心元素，使它位于输入图像待处理像素的正上方 。

将输入图像的像素值作为权重，乘以相关核。众所周知，像素点就是`RGB`的矩阵构成的，卷积核的系数乘以在卷积核覆盖的图片的像素值相加就得到了新的数，我们把这些数相加便完成了。

将上面各步得到的结果相加做为输出 **简单来说就是根据高斯分布得到高斯模板然后做卷积相加的一个过程。**



```
# 应用高斯滤波
# 第二个参数是高斯核的大小，必须是正的奇数
# 第三个参数是标准差，如果为0，则根据核大小自动计算
gaussian_blur = cv2.GaussianBlur(image, (5, 5), 0)

# 显示原图和滤波后的图像
cv2.imshow('Original Image', image)
cv2.imshow('Gaussian Blurred Image', gaussian_blur)
```

在图像处理中，使用正的奇数大小的核（kernel）进行高斯滤波或其他卷积操作有几个重要原因：

中心像素：使用奇数大小的核可以确保有一个明确的中心像素。在卷积操作中，核是围绕这个中心像素对图像进行操作的。这对于确保滤波操作均匀地影响周围像素非常重要。如果使用偶数大小的核，就没有一个单独的中心像素，这会使得滤波操作的对称性和均匀性受到影响。

边界处理：当核在图像上移动时，中心像素可以遍历图像的每一个位置。如果核的大小是奇数，那么核的边界可以在图像边界的正外侧相等距离地扩展，这使得边界像素可以和中心像素一样得到有效处理。

数学对称性：高斯滤波本质上是一种基于高斯函数的权重平均。高斯函数是对称的，因此使用奇数大小的核可以在数学上更自然地表示这种对称性，使得核中的每个元素都可以围绕中心对称排列。

实用考虑：在很多图像处理库和算法中，都采用了奇数大小的核。这已经成为了一种常规做法，既是因为上述原因，也是因为这样的设计在实际应用中表现良好。

因此，虽然理论上可以使用偶数大小的核，但在实际应用中，使用奇数大小的核可以更有效地实现图像处理目标，同时保持算法的简单性和一致性。



### 边缘检测

边缘检测的目的是标识数字图像中亮度变化明显的点。图像属性中的显著变化通常反映了属性的重要事件和变化。

边缘检测会用到特定的滤波器或者算子（`sobel`，`canny`，`prewitt`，`laplacian算子`）来高亮显示图像的边缘。



**边缘检测的工作原理：**

1. **突出显示边缘**：边缘检测算法通过增强图像中亮度或颜色的快速变化来检测边缘。这些变化通常出现在对象的轮廓或其他重要特征的边界上。

2. **使用导数**：边缘检测算法通常基于计算图像强度的一阶导数（如`Sobel`或`Prewitt算子`）或二阶导数（如`Laplacian算子`）。这些导数帮助确定像素强度变化的位置和程度。

3. **滤波器应用**：边缘检测滤波器在图像上应用，类似于其他类型的图像滤波，但是这些滤波器专门设计来响应边缘。

 **边缘检测的特点：**

- **高对比度区域响应**：边缘检测滤波器对高对比度区域（如明暗边界）有很强的响应。

- **不同方向的响应**：有些边缘检测算子（如`Sobel`）包含多个核，分别响应不同方向的边缘（如水平和垂直边缘）。

- **噪声敏感性**：由于边缘检测强调了图像中的快速变化，它可能对噪声也很敏感。因此，在应用边缘检测之前，通常需要进行噪声降低处理。



在介绍完滤波的知识后，学习基本边缘检测算法是一件很轻松的事情，因为边缘检测本质上就是一种滤波算法，区别在于滤波器的选择，滤波的规则是完全一致的。



为了更好理解边缘检测算子，我们引入梯度(gradient)这一概念，梯度是人工智能(artificial intelligence)非常重要的一个概念，遍布机器学习、深度学习领域，学过微积分的同学应该知道一维函数的一阶微分基本定义为：
$$
\frac{df}{dx} = \lim_{\varepsilon \to 0} \frac{f(x + \varepsilon) - f(x)}{\varepsilon}
$$
图像的滤波一般是**基于灰度图**进行的，因此图像此时是二维的，因此我们在看一下二维函数的微分，即偏微分方程：
$$
\frac{\partial f(x, y)}{\partial x} = \lim_{\varepsilon \to 0} \frac{f(x + \varepsilon, y) - f(x, y)}{\varepsilon}
$$

$$
\frac{\partial f(x, y)}{\partial y} = \lim_{\varepsilon \to 0} \frac{f(x, y + \varepsilon) - f(x, y)}{\varepsilon}
$$

图像梯度即当前所在像素点对于X轴、Y轴的**偏导数**，所以梯度在图像处理领域我们可以也理解为像素灰度值**变化的速度**，下面我们举一个简单的例子

![](/home/plote/Self-taught deep learning/img/17.png)

**梯度的模**则表示f(x, y)，在其最大变化率方向上的单位距离所增加的量，即：
$$
Gf(x, y) = \left[ \left( \frac{\partial f}{\partial x} \right)^2 + \left( \frac{\partial f}{\partial y} \right)^2 \right]^{1/2}
$$






#### sobel边缘检测：

`sobel`算子

该算子包含2组$3*3$的矩阵，分别为横向及纵向，应用算子与图像的像素做卷积，即可以得出横向和纵向的亮度差分近似值。

如果A表示原始图像，$G_X$ 和$G_Y$分别代表经横向及纵向边缘检测的图像。

- 是一种简单的梯度算法，用于找到图像亮度的空间梯度。
- 它使用两个3x3的滤波器，分别用于水平和垂直方向的边缘检测。
- 结果是两个梯度图的直接组合，表示边缘的强度和方向。

$G_X$变换矩阵就是$G_Y$
$$
G_x = 
\begin{bmatrix}
+1 & 0 & -1 \\
+2 & 0 & -2 \\
+1 & 0 & -1
\end{bmatrix}
* A
$$

$$
G_y = 
\begin{bmatrix}
+1 & +2 & +1 \\
 0 &  0 &  0 \\
-1 & -2 & -1
\end{bmatrix}
* A
$$

![](/home/plote/Self-taught deep learning/img/7.png)

这些内核被设计为最大程度地响应相对于像素网格垂直和水平运行的边缘，两个垂直方向各有一个内核。内核可以单独应用于输入图像，以生成每个方向上梯度分量的单独测量（称为*Gx*和 *Gy*）。然后可以将它们组合在一起以找到每个点处梯度的绝对大小以及该梯度的方向。

然后在水平和垂直方向上用Sobel核对平滑后的图像进行滤波，以获得水平方向$G_{x}$ 和垂直方向 $G_{y}$的一阶导数。从这两个图像中，我们可以找到每个像素的边缘梯度和方向，如下所示：
$$
Edge_Gradient\left ( G \right )= \sqrt{G_{x}^{2}+G_{y}^{2}}
$$

产生空间梯度的边缘方向角（相对于像素网格）由下式给出：
$$
Angle\left ( \theta \right )= tan^{-1}\left ( \frac{G_{y}}{G_{x}} \right )
$$



#### canny边缘检测：

**Canny 算法**：
- 是一种更复杂的多阶段算法，旨在提供更清晰、更细腻的边缘检测。
- 它包括噪声降低、梯度计算、非极大值抑制、双阈值和边缘跟踪通过滞后。
- Canny 边缘检测器尝试最小化错误报告的边缘，并准确定位边缘。

##### 边缘检测的步骤：

- **使用高斯滤波，以平滑曲线，去滤出噪声**

   这里使用平滑曲线主要原因是因为要求去算梯度，无关噪声会直接影响梯度

- **计算图像每个像素点的梯度强度和方向**

   

- **应用非极大值抑制，以消除边缘检测带来的杂散相应**

   **非极大值抑制**，简称为NMS算法，英文为Non-Maximum Suppression。其思想是搜素局部最大值，抑制非极大值。NMS算法在不同应用中的具体实现不太一样，但思想是一样的。非极大值抑制，在计算机视觉任务中得到了广泛的应用，例如边缘检测、人脸检测、目标检测（DPM，YOLO，SSD，Faster R-CNN）等。

   以目标检测为例：目标检测的过程中在同一目标的位置上会产生大量的候选框，这些候选框相互之间可能会有重叠，此时我们需要利用非极大值抑制找到最佳的目标边界框，消除冗余的边界框。

   非极大值抑制来消除冗余框。基本思想是，如果有多个预测框都对应同一个物体，则只选出得分最高的那个预测框，剩下的预测框被丢弃掉。

   ![](https://pic1.zhimg.com/80/v2-47e7516f615632e92f6e9e3f7463c3f4_1440w.webp)



- **应用双阈值检测来检测确定真实的和潜在的边缘**

其目的是通过设置两个阈值来对梯度图像进行二值化，将梯度值高于高阈值的像素点视为强边缘，将梯度值低于低阈值的像素点视为非边缘，而位于两个阈值之间的像素点则根据其是否与强边缘相连来确定其是否为边缘。

具体地说，双阈值处理包括以下步骤：

1. 对图像进行高斯平滑滤波，计算图像的梯度幅值和方向。
2. 根据设定的高阈值和低阈值，将梯度幅值图像分为三类像素点：强边缘、弱边缘和非边缘。
3. 对强边缘像素点进行保留，对非边缘像素点进行舍弃。
4. 对弱边缘像素点进行进一步处理，如果其与强边缘像素点相邻，则将其视为边缘像素点，否则将其视为非边缘像素点。





























